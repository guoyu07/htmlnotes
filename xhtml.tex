\part{XHTML}


XHTML (Extensible HyperText Markup Language) is a family of XML markup languages that mirror or extend versions of the widely used Hypertext Markup Language (HTML), the language in which web pages are written.

While HTML (prior to HTML5) was defined as an application of Standard Generalized Markup Language (SGML), a very flexible markup language framework, XHTML is an application of XML, a more restrictive subset of SGML. Because XHTML documents need to be well-formed, they can be parsed using standard XML parsers—unlike HTML, which requires a lenient HTML-specific parser.

XHTML 1.0 became a World Wide Web Consortium (W3C) Recommendation on January 26, 2000. XHTML 1.1 became a W3C Recommendation on May 31, 2001. XHTML5 is undergoing development as of September 2009, as part of the HTML5 specification.

W3C于2001年1月发布了作为推荐标准的XHTML（可扩展超文本标记语言），可以认为XHTML是以XML格式编写的HTML，而且XHTML与HTML4.01几乎是相同的，XHTML 的目标是取代 HTML。



如果在浏览器中查看，很多HTML代码运行起来非常正常，即使它并未遵守HTML规则，而XML是一种必须正确标记且格式良好的标记语言。

XHTML 是作为一种 XML 应用被重新定义的 HTML，因此XHTML相比HTML更严格更纯净，XHTML 于2000年的1月26日成为 W3C 标准，W3C 将 XHTML 定义为最新的HTML版本，XHTML 将逐渐取代 HTML。目前XHTML已经得到所有主流浏览器的支持。

科技界存在一些不同的浏览器技术。其中一些在计算机上运行，而另一些可能在移动电话或其他小型设备上运行，而后者往往缺乏解释“糟糕”的标记语言的资源和能力，于是W3C结合XML和HTML的长处，开发出了 XHTML。

XHTML 是 HTML 与 XML（扩展标记语言）的结合物，XHTML 包含了所有与 XML 语法结合的 HTML 4.01 元素，可以认为XHTML 是以 XML 重构的 HTML 4.01。

XHTML与 HTML 相比最重要的区别如下：

\begin{compactitem}
\item 文档结构

	\begin{compactitem}
	\item XHTML DOCTYPE是强制性的
	\item <html> 中的 XML namespace属性是强制性的
	\item <html>、<head>、<title> 以及 <body> 也是强制性的
	\end{compactitem}

XHTML文档必须进行XHTML文档类型声明（XHTML DOCTYPE declaration）。

<html>、<head>、<title> 以及 <body> 元素也必须存在，并且必须使用 <html> 中的 xmlns 属性为文档规定 xml 命名空间。

下面的例子展示了带有最少的必需标签的 XHTML 文档：

\begin{lstlisting}[language=HTML]
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Title of document</title>
</head>
<body>
......
</body>
</html>
\end{lstlisting}

\item 元素语法

	\begin{compactitem}
	\item XHTML 元素必须正确嵌套

在 HTML 中，某些元素可以不正确地彼此嵌套在一起，就像这样：

\begin{lstlisting}[language=HTML]
	<b><i>This text is bold and italic</b></i>
\end{lstlisting}

在 XHTML 中，所有元素必须正确地彼此嵌套，就像这样：

\begin{lstlisting}[language=HTML]
	<b><i>This text is bold and italic</i></b>
\end{lstlisting}

	\item XHTML 元素必须始终关闭

在XHTML中，以下语法是错误的：

\begin{lstlisting}[language=HTML]
<p>This is a paragraph
<p>This is another paragraph
\end{lstlisting}

必须写成这样：

\begin{lstlisting}[language=HTML]
<p>This is a paragraph</p>
<p>This is another paragraph</p>
\end{lstlisting}

	\item XHTML 元素必须小写

XHTML是大小写敏感的，所有XHTML元素必须小写，而这些在HTML中是允许的。

\begin{lstlisting}[language=HTML]
<BODY>
<P>This is a paragraph</P>
</BODY>
\end{lstlisting}

在XHTML中，只能写成这样：

\begin{lstlisting}[language=HTML]
<body>
<p>This is a paragraph</p>
</body>
\end{lstlisting}

	\item XHTML 文档必须有一个根元素

	\end{compactitem}





另外，在XHTML中的空元素也必须关闭\footnote{应该在 "/" 符号前添加一个额外的空格，以使XHTML与当前的浏览器相兼容。}：

\begin{lstlisting}[language=HTML]
A break: <br />
A horizontal rule: <hr />
An image: <img src="happy.gif" alt="Happy face" />
\end{lstlisting}

下面这些以前在HTML中正常运行的代码片段在XHTML中是错误的：

\begin{lstlisting}[language=HTML]
A break: <br>
A horizontal rule: <hr>
An image: <img src="happy.gif" alt="Happy face">
\end{lstlisting}



\item 属性语法

	\begin{compactitem}
	\item XHTML 属性必须使用小写

以前在HTML中有效的大写属性在XHTML中是错误的，比如以下：

\begin{lstlisting}[language=HTML]
<table WIDTH="100%">
\end{lstlisting}

在XHTML中，必须代之以：

\begin{lstlisting}[language=HTML]
<table width="100%">
\end{lstlisting}

	\item XHTML 属性值必须用引号包围

HTML属性值可以没有引号，但XHTML属性值必须用引号包围，下面的代码在XHTML中是错误的，但在HTML中是有效的：

\begin{lstlisting}[language=HTML]
<table width=100%>
\end{lstlisting}

在XHTML中，必须代之以：

\begin{lstlisting}[language=HTML]
<table width="100%">
\end{lstlisting}

	\item XHTML 属性最小化也是禁止的

XHTML中属性简写是错误的，比如：

\begin{lstlisting}[language=HTML]
<input checked>
<input readonly>
<input disabled>
<option selected>
\end{lstlisting}

必须写成：

\begin{lstlisting}[language=HTML]
<input checked="checked" />
<input readonly="readonly" />
<input disabled="disabled" />
<option selected="selected" />
\end{lstlisting}

	\end{compactitem}





\end{compactitem}

XML 是一种标记化语言，其中所有的东西都要被正确的标记，以产生形式良好的文档。XML 用来描述数据，而 HTML 则用来显示数据，因此，从HTML转换到XHTML的步骤如下：

\begin{compactenum}
\item 向每张页面的第一行添加 XHTML <!DOCTYPE>
\item 向每张页面的 html 元素添加 xmlns 属性
\item 把所有元素名改为小写
\item 关闭所有空元素
\item 把所有属性名改为小写
\item 为所有属性值加引号
\end{compactenum}

XHTML 可以被所有的支持 XML 的设备读取，同时在其余的浏览器升级至支持 XML 之前，XHTML 使我们有能力编写出拥有良好结构的文档，这些文档可以很好地工作于所有的浏览器，并且可以向后兼容。

总结：

\begin{compactitem}
\item 所有的 XHTML 元素都必须被正确地嵌套，XHTML 必须拥有良好的结构，所有的标签必须小写，并且所有的 XHTML 元素必须被关闭。
\item 所有的 XHTML 文档必须拥有 DOCTYPE 声明，并且 html、head、title 和 body 元素必须存在。
\end{compactitem}


\chapter{Overview}

XHTML 1.0 is "a reformulation of the three HTML 4 document types as applications of XML 1.0". The World Wide Web Consortium (W3C) also continues to maintain the HTML 4.01 Recommendation, and the specifications for HTML5 and XHTML5 are being actively developed. In the current XHTML 1.0 Recommendation document, as published and revised to August 2002, the W3C commented that, "The XHTML family is the next step in the evolution of the Internet. By migrating to XHTML today, content developers can enter the XML world with all of its attendant benefits, while still remaining confident in their content's backward and future compatibility."

However, in 2005, the Web Hypertext Application Technology Working Group (WHATWG) formed, independently of the W3C, to work on advancing ordinary HTML not based on XHTML. The WHATWG eventually began working on a standard that supported both XML and non-XML serializations, HTML5, in parallel to W3C standards such as XHTML 2. In 2007, the W3C's HTML working group voted to officially recognize HTML5 and work on it as the next-generated HTML standard. In 2009, the W3C allowed the XHTML 2 Working Group's charter to expire, acknowledging that HTML5 would be the sole next-generation HTML standard, including both XML and non-XML serializations. Of the two serializations, the W3C suggests that most authors use the HTML syntax, rather than the XHTML syntax.

\section{Motivation}

XHTML was developed to make HTML more extensible and increase interoperability with other data formats. HTML 4 was ostensibly an application of Standard Generalized Markup Language (SGML); however the specification for SGML was complex, and neither web browsers nor the HTML 4 Recommendation were fully conformant to it. The XML standard, approved in 1998, provided a simpler data format closer in simplicity to HTML 4. By shifting to an XML format, it was hoped HTML would become compatible with common XML tools; servers and proxies would be able to transform content, as necessary, for constrained devices such as mobile phones. By using namespaces, XHTML documents could provide extensibility by including fragments from other XML-based languages such as Scalable Vector Graphics and MathML. Finally, the renewed work would provide an opportunity to divide HTML into reusable components (XHTML Modularization) and clean up untidy parts of the language.


\section{Relationship to HTML}

There are various differences between XHTML and HTML. The Document Object Model is a tree structure that represents the page internally in applications, and XHTML and HTML are two different ways of representing that in markup (serializations). Both are less expressive than the DOM (for example, "--" may be placed in comments in the DOM, but cannot be represented in a comment in either XHTML or HTML), and generally XHTML's XML syntax is a little more expressive than HTML (for example, arbitrary namespaces are not allowed in HTML). First off, one source of differences is immediate: XHTML uses an XML syntax, while HTML uses a pseudo-SGML syntax (officially SGML for HTML 4 and under, but never in practice, and standardised away from SGML in HTML5). Secondly however, because the expressible contents of the DOM in syntax are slightly different, there are some changes in actual behavior between the two models.


First, there are some differences in syntax:

\begin{compactitem}
\item Broadly, the XML rules require that all elements be closed, either by a separate closing tag or using self-closing syntax (e.g. <br />), while HTML syntax permits some elements to be unclosed because either they are always empty (e.g. <input>) or their end can be determined implicitly ("omissibility", e.g. <p>).
\item XML is case-sensitive for element and attribute names, while HTML is not.
\item Some shorthand features in HTML are omitted in XML, such as (1) attribute minimization, where attribute values or their quotes may be omitted (e.g. <option selected> or <option selected=selected>, while in XML this must be expressed as <option selected="selected">); (2) element minimization may be used to remove elements entirely (such as <tbody> inferred in a table if not given); and (3) the rarely used SGML syntax for element minimization ("shorttag"), which most browsers do not implement.[13]
\item There are numerous other technical requirements surrounding namespaces and precise parsing of whitespace and certain characters and elements. The exact parsing of HTML in practice has been undefined until recently;
\end{compactitem}


Secondly, in contrast to these minor syntactical differences, there are some behavioral differences, mostly arising from the underlying differences in serialization. For example:

\begin{compactitem}
\item Most prominently, behavior on parse errors differ. A fatal parse error in XML (such as an incorrect tag structure) causes document processing to be aborted.
\item Most content requiring namespaces will not work in HTML, except the built-in support for SVG and MathML in the HTML5 parser along with certain magic prefixes such as xlink.
\item JavaScript processing is a little different in XHTML, with minor changes in case sensitivity to some functions, and further precautions to restrict processing to well-formed content. Scripts must not use the document.write() method; it is not available for XHTML. The innerHTML property is available, but will not insert non-well-formed content. On the other hand, it can be used to insert well-formed namespaced content into XHTML.
\item CSS is also applied slightly differently. Due to XHTML's case-sensitivity, all CSS selectors become case sensitive for XHTML documents.[14] Some CSS properties, such as backgrounds, set on the <body> element in HTML are 'inherited upwards' into the <html> element; this appears not to be the case for XHTML.
\end{compactitem}




\section{Adoption}

The similarities between HTML 4.01 and XHTML 1.0 led many web sites and content management systems to adopt the initial W3C XHTML 1.0 Recommendation. To aid authors in the transition, the W3C provided guidance on how to publish XHTML 1.0 documents in an HTML-compatible manner, and serve them to browsers that were not designed for XHTML.


Such "HTML-compatible" content is sent using the HTML media type (text/html) rather than the official Internet media type for XHTML (application/xhtml+xml). When measuring the adoption of XHTML to that of regular HTML, therefore, it is important to distinguish whether it is media type usage or actual document contents that is being compared.

Most web browsers have mature support[18] for all of the possible XHTML media types. The notable exception is Internet Explorer versions 8 and earlier by Microsoft; rather than rendering application/xhtml+xml content, a dialog box invites the user to save the content to disk instead. Both Internet Explorer 7 (released in 2006) and Internet Explorer 8 (released in March 2009) exhibit this behavior. Microsoft developer Chris Wilson explained in 2005 that IE7’s priorities were improved browser security and CSS support, and that proper XHTML support would be difficult to graft onto IE’s compatibility-oriented HTML parser; however, Microsoft added support for true XHTML in IE9.

As long as support is not widespread, most web developers avoid using XHTML that is not HTML-compatible, so advantages of XML such as namespaces, faster parsing and smaller-footprint browsers do not benefit the user.


\section{Criticism}

In the early 2000s, some web developers began to question why Web authors ever made the leap into authoring in XHTML. Others countered that the problems ascribed to the use of XHTML could mostly be attributed to two main sources: the production of invalid XHTML documents by some Web authors and the lack of support for XHTML built into Internet Explorer 6. They went on to describe the benefits of XML-based Web documents (i.e. XHTML) regarding searching, indexing and parsing as well as future-proofing the Web itself.


In October 2006, HTML inventor and W3C chair Tim Berners-Lee, introducing a major W3C effort to develop a new HTML specification, posted in his blog that, "The attempt to get the world to switch to XML … all at once didn't work. The large HTML-generating public did not move … Some large communities did shift and are enjoying the fruits of well-formed systems … The plan is to charter a completely new HTML group." The current HTML5 working draft says "special attention has been given to defining clear conformance criteria for user agents in an effort to improve interoperability … while at the same time updating the HTML specifications to address issues raised in the past few years." Ian Hickson, editor of the HTML5 specification criticising the improper use of XHTML in 2002, is a member of the group developing this specification and is listed as one of the co-editors of the current working draft.

Simon Pieters researched the XML-compliance of mobile browsers and concluded “the claim that XHTML would be needed for mobile devices is simply a myth”.



\chapter{Versions of XHTML}





\section{XHTML 1.0}

December 1998 saw the publication of a W3C Working Draft entitled Reformulating HTML in XML. This introduced Voyager, the codename for a new markup language based on HTML 4, but adhering to the stricter syntax rules of XML. By February 1999 the name of the specification had changed to XHTML 1.0: The Extensible HyperText Markup Language, and in January 2000 it was officially adopted as a W3C Recommendation. There are three formal DTDs for XHTML 1.0, corresponding to the three different versions of HTML 4.01:

\begin{compactitem}
\item XHTML 1.0 Strict is the XML equivalent to strict HTML 4.01, and includes elements and attributes that have not been marked deprecated in the HTML 4.01 specification. As of May 25, 2011, XHTML 1.0 Strict is the document type used for the homepage of the website of the World Wide Web Consortium.

\item XHTML 1.0 Transitional is the XML equivalent of HTML 4.01 Transitional, and includes the presentational elements (such as center, font and strike) excluded from the strict version.

\item XHTML 1.0 Frameset is the XML equivalent of HTML 4.01 Frameset, and allows for the definition of frameset documents—a common Web feature in the late 1990s.

\end{compactitem}

The second edition of XHTML 1.0 became a W3C Recommendation in August 2002.




\section{Modularization of XHTML}

Modularization provides an abstract collection of components through which XHTML can be subsetted and extended. The feature is intended to help XHTML extend its reach onto emerging platforms, such as mobile devices and Web-enabled televisions. The initial draft of Modularization of XHTML became available in April 1999, and reached Recommendation status in April 2001.

The first modular XHTML variants were XHTML 1.1 and XHTML Basic 1.0.

In October 2008 Modularization of XHTML was superseded by XHTML Modularization 1.1, which adds an XML Schema implementation. It was itself superseded by a second edition in July 2010.




\section{XHTML 1.1:Module-based XHTML}


XHTML 1.1 evolved out of the work surrounding the initial Modularization of XHTML specification. The W3C released a first draft in September 1999; Recommendation status was reached in May 2001.[36] The modules combined within XHTML 1.1 effectively recreate XHTML 1.0 Strict, with the addition of ruby annotation elements (ruby, rbc, rtc, rb, rt and rp) to better support East-Asian languages. Other changes include removal of the name attribute from the a and map elements, and (in the first edition of the language) removal of the lang attribute in favour of xml:lang.

Although XHTML 1.1 is largely compatible with XHTML 1.0 and HTML 4, in August 2002 the Working Group issued a formal Note advising that it should not be transmitted with the HTML media type.[37] With limited browser support for the alternate application/xhtml+xml media type, XHTML 1.1 proved unable to gain widespread use. In January 2009 a second edition of the document (XHTML Media Types - Second Edition) was issued, relaxing this restriction and allowing XHTML 1.1 to be served as text/html.

A second edition of XHTML 1.1 was issued on 23 November 2010, which addresses various errata and adds an XML Schema implementation not included in the original specification.[39] (It was first released briefly on 7 May 2009 as a "Proposed Edited Recommendation"[40] before being rescinded on 19 May due to unresolved issues.)


Of all the versions of XHTML, XHTML Basic 1.0 provides the fewest features. With XHTML 1.1, it is one of the two first implementations of modular XHTML. In addition to the Core Modules (Structure, Text, Hypertext, and List), it implements the following abstract modules: Base, Basic Forms, Basic Tables, Image, Link, Metainformation, Object, Style Sheet, and Target.

XHTML Basic 1.1 replaces the Basic Forms Module with the Forms Module, and adds the Intrinsic Events, Presentation, and Scripting modules. It also supports additional tags and attributes from other modules. This version became a W3C recommendation on 29 July 2008.

The current version of XHTML Basic is 1.1 Second Edition (23 November 2010), in which the language is re-implemented in the W3C's XML Schema language. This version also supports the lang attribute.



\subsection{XHTML-Print}


XHTML-Print, which became a W3C Recommendation in September 2006, is a specialized version of XHTML Basic designed for documents printed from information appliances to low-end printers.

\section{XHTML Mobile Profile}


XHTML Mobile Profile (abbreviated XHTML MP or XHTML-MP) is a third-party variant of the W3C's XHTML Basic specification. Like XHTML Basic, XHTML was developed for information appliances with limited system resources.

In October 2001, a limited company called the Wireless Application Protocol Forum began adapting XHTML Basic for WAP 2.0, the second major version of the Wireless Application Protocol. WAP Forum based their DTD on the W3C's Modularization of XHTML, incorporating the same modules the W3C used in XHTML Basic 1.0—except for the Target Module. Starting with this foundation, the WAP Forum replaced the Basic Forms Module with a partial implementation of the Forms Module, added partial support for the Legacy and Presentation modules, and added full support for the Style Attribute Module.

In 2002, the WAP Forum was subsumed into the Open Mobile Alliance (OMA), which continued to develop XHTML Mobile Profile as a component of their OMA Browsing Specification.


\subsection{XHTML Mobile Profile 1.1}

To this version, finalized in 2004, the OMA added partial support for the Scripting Module, and partial support for Intrinsic Events. XHTML MP 1.1 is part of v2.1 of the OMA Browsing Specification (1 November 2002).




\subsection{XHTML Mobile Profile 1.2}

This version, finalized 27 February 2007, expands the capabilities of XHTML MP 1.1 with full support for the Forms Module and OMA Text Input Modes. XHTML MP 1.2 is part of v2.3 of the OMA Browsing Specification (13 March 2007).


\subsection{XHTML Mobile Profile 1.3}

XHTML MP 1.3 (finalized on 23 September 2008) uses the XHTML Basic 1.1 document type definition, which includes the Target Module. Events in this version of the specification are updated to DOM Level 3 specifications (i.e., they are platform- and language-neutral).


\section{XHTML 1.2}

The XHTML 2 Working Group considered the creation of a new language based on XHTML 1.1. If XHTML 1.2 was created, it would include WAI-ARIA and role attributes to better support accessible web applications, and improved Semantic Web support through RDFa. The inputmode attribute from XHTML Basic 1.1, along with the target attribute (for specifying frame targets) might also be present. The XHTML2 WG had not been chartered to carry out the development of XHTML1.2. Since the W3C announced that it does not intend to recharter the XHTML2 WG, and closed the WG in December 2010, this means that XHTML 1.2 proposal would not eventuate.


\section{XHTML 2.0}


Between August 2002 and July 2006, the W3C released eight Working Drafts of XHTML 2.0, a new version of XHTML able to make a clean break from the past by discarding the requirement of backward compatibility. This lack of compatibility with XHTML 1.x and HTML 4 caused some early controversy in the web developer community. Some parts of the language (such as the role and RDFa attributes) were subsequently split out of the specification and worked on as separate modules, partially to help make the transition from XHTML 1.x to XHTML 2.0 smoother. A ninth draft of XHTML 2.0 was expected to appear in 2009, but on July 2, 2009, the W3C decided to let the XHTML2 Working Group charter expire by that year's end, effectively halting any further development of the draft into a standard. Instead, XHTML 2.0 and its related documents were released as W3C Notes.

New features to have been introduced by XHTML 2.0 included:

\begin{compactitem}
\item HTML forms were to be replaced by XForms, an XML-based user input specification allowing forms to be displayed appropriately for different rendering devices.

\item HTML frames were to be replaced by XFrames.

\item The DOM Events were to be replaced by XML Events, which uses the XML Document Object Model.

\item A new list element type, the nl element type, were to be included to specifically designate a list as a navigation list. This would have been useful in creating nested menus, which are currently created by a wide variety of means like nested unordered lists or nested definition lists.

\item Any element was to be able to act as a hyperlink, e. g., <li href="articles.html">Articles</li>, similar to XLink. However, XLink itself is not compatible with XHTML due to design differences.

\item Any element was to be able to reference alternative media with the src attribute, e. g., <p src="lbridge.jpg" type="image/jpeg">London Bridge</p> is the same as <object src="lbridge.jpg" type="image/jpeg"><p>London Bridge</p></object>.

\item The alt attribute of the img element was removed: alternative text was to be given in the content of the img element, much like the object element, e. g., <img src="hms\_audacious.jpg">HMS <span class="italic">Audacious</span></img>.

\item A single heading element (h) was added. The level of these headings was determined by the depth of the nesting. This would have allowed the use of headings to be infinite, rather than limiting use to six levels deep.

\item The remaining presentational elements i, b and tt, still allowed in XHTML 1.x (even Strict), were to be absent from XHTML 2.0. The only somewhat presentational elements remaining were to be sup and sub for superscript and subscript respectively, because they have significant non-presentational uses and are required by certain languages. All other tags were meant to be semantic instead (e. g. strong for strong emphasis) while allowing the user agent to control the presentation of elements via CSS (e.g. rendered as boldface text in most visual browsers, but possibly rendered with changes of tone in a text-to-speech reader, larger + italic font per rules in a user-end stylesheet, etc.).

\item The addition of RDF triple with the property and about attributes to facilitate the conversion from XHTML to RDF/XML.
\end{compactitem}


\section{XHTML5}


HTML5 initially grew independently of the W3C, through a loose group of browser manufacturers and other interested parties calling themselves the WHATWG, or Web Hypertext Application Technology Working Group. The WHATWG announced the existence of an open mailing list in June 2004, along with a website bearing the strapline “Maintaining and evolving HTML since 2004.” The key motive of the group was to create a platform for dynamic web applications; they considered XHTML 2.0 to be too document-centric, and not suitable for the creation of internet forum sites or online shops.

In April 2007, the Mozilla Foundation and Opera Software joined Apple in requesting that the newly rechartered HTML Working Group of the W3C adopt the work, under the name of HTML5. The group resolved to do this the following month, and the First Public Working Draft of HTML5 was issued by the W3C in January 2008. The most recent W3C Working Draft was published in January 2011.

HTML5 has both a regular text/html serialization and an XML serialization, which is known as XHTML5. In addition to the markup language, the specification includes a number of application programming interfaces. The Document Object Model is extended with APIs for editing, drag-and-drop, data storage and network communication.

The language is more compatible with HTML 4 and XHTML 1.x than XHTML 2.0, due to the decision to keep the existing HTML form elements and events model. It adds many new elements not found in XHTML 1.x, however, such as section and aside.


The most recent draft includes WAI-ARIA support.









\chapter{Semantic content in XHTML}

XHTML+RDFa is an extended version of the XHTML markup language for supporting RDF through a collection of attributes and processing rules in the form of well-formed XML documents. This host language is one of the techniques used to develop Semantic Web content by embedding rich semantic markup.



\chapter{Valid XHTML documents}

An XHTML document that conforms to an XHTML specification is said to be valid. Validity assures consistency in document code, which in turn eases processing, but does not necessarily ensure consistent rendering by browsers. A document can be checked for validity with the W3C Markup Validation Service. In practice, many web development programs provide code validation based on the W3C standards.

\begin{compactitem}
\item XHTML 元素必须被正确地嵌套。
\item XHTML 元素必须被关闭。
\item 标签名必须用小写字母。
\item XHTML 文档必须拥有根元素。
\item 属性名称必须小写
\item 属性值必须加引号
\item 属性不能简写
\item 用id属性代替 name 属性
\item XHTML DTD 定义了强制使用的 HTML 元素
\end{compactitem}

下面是一个 HTML 的简写属性列表，以及在 XHTML 中的改写：

\begin{longtable}{|p{80pt}|p{200pt}|}
%head
\multicolumn{2}{r}{...}
\tabularnewline\hline
HTML	&XHTML
\endhead
%endhead

%firsthead
\caption{HTML 的简写属性列表，以及在 XHTML 中的改写}\\
\hline
HTML	&XHTML
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{...}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
compact	&compact="compact"\\
\hline
checked	&checked="checked"\\
\hline
declare	&declare="declare"\\
\hline
readonly	&readonly="readonly''\\
\hline
disabled	&disabled="disabled"\\
\hline
selected	&selected="selected"\\
\hline
defer	&defer="defer"\\
\hline
ismap	&ismap="ismap"\\
\hline
nohref	&nohref="nohref"\\
\hline
noshade	&noshade="noshade"\\
\hline
nowrap	&nowrap="nowrap"\\
\hline
multiple	&multiple="multiple"\\
\hline
noresize	&noresize="noresize"\\
\hline
\end{longtable}

HTML 4.01 针对下列元素定义 name 属性：a, applet, frame, iframe, img, 和map，但是在 XHTML 中不鼓励使用 name 属性，应该使用 id 取而代之。

下面的代码在XHTML中是错误的：

\begin{lstlisting}[language=HTML]
<img src="picture.gif" name="pic" />
\end{lstlisting}

要把name属性改为id。

\begin{lstlisting}[language=HTML]
<img src="picture.gif" id="pic" />
\end{lstlisting}


\section{Root element}

The root element of an XHTML document must be html, and must contain an xmlns attribute to associate it with the XHTML namespace. The namespace URI for XHTML is http://www.w3.org/1999/xhtml. The example tag below additionally features an xml:lang attribute to identify the document with a natural language:

\begin{lstlisting}[language=HTML]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
\end{lstlisting}

XHTML 文档必须拥有一个根元素，所有的 XHTML 元素必须被嵌套于 <html> 根元素中。其余所有的元素均可有子元素。子元素必须是成对的且被嵌套在其父元素之中。基本的文档结构如下：

\begin{lstlisting}[language=HTML]
<html>
  <head> ... </head>
  <body> ... </body>
</html>
\end{lstlisting}


\section{DOCTYPEs}

In order to validate an XHTML document, a Document Type Declaration, or DOCTYPE, may be used. A DOCTYPE declares to the browser the Document Type Definition (DTD) to which the document conforms. A Document Type Declaration should be placed before the root element.

The system identifier part of the DOCTYPE, which in these examples is the URL that begins with http://, need only point to a copy of the DTD to use, if the validator cannot locate one based on the public identifier (the other quoted string). It does not need to be the specific URL that is in these examples; in fact, authors are encouraged to use local copies of the DTD files when possible. The public identifier, however, must be character-for-character the same as in the examples.

所有 XHTML 文档必须进行文件类型声明（DOCTYPE declaration）。在 XHTML 文档中必须存在html、head、body元素，而 title 元素必须位于在 head 元素中。

下面是一个最小化的 XHTML 文件模板：

\begin{lstlisting}[language=HTML]
<!DOCTYPE Doctype goes here>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Title goes here</title>
  </head>
  <body>
  </body>
</html>
\end{lstlisting}

例如：

\begin{lstlisting}[language=HTML]
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Title goes here</title>
  </head>
  <body>
  </body>
</html>
\end{lstlisting}

文件类型声明并非 XHTML 文档自身的组成部分。它并不是 XHTML 元素，也没有关闭标签。

在 XHTML 中，<html> 标签内的 xmlns 属性是必需的。然而，即使当 XHTML 文档中没有这个属性时，w3.org 的验证工具也不会提示错误\footnote{这是因为，``xmlns=http://www.w3.org/1999/xhtml" 是一个固定的值，即使开发者没有把它包含在代码中，这个值也会被添加到 <html> 标签中。}。

XHTML 定义了三种文件类型声明，其中使用最普遍的是 XHTML Transitional。



一个 XHTML 文档有三个主要的部分：

\begin{compactitem}
\item \texttt{DOCTYPE}
\item \texttt{Head}
\item \texttt{Body}
\end{compactitem}

基本的文档结构是这样的：

\begin{lstlisting}[language=HTML]
<!DOCTYPE ...>
<html>
  <head>
    <title>... </title>
  </head>
  <body> ... </body>
</html>
\end{lstlisting}

在 XHTML 文档中，文档类型声明总是位于首行，而且\texttt{\textcolor{Blue}{<!DOCTYPE>}}是强制使用的。

下面是这个一个简单的（最小化的） XHTML 文档：

\begin{lstlisting}[language=HTML]
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>simple document</title>
  </head>
  <body>
    <p>a simple paragraph</p>
  </body>
</html>
\end{lstlisting}

文档类型声明定义文档的类型：

\begin{lstlisting}[language=HTML]
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
\end{lstlisting}

关于DTD，有：

\begin{compactitem}
\item DTD 规定了使用通用标记语言(SGML)的网页的语法。
\item 诸如 HTML 这样的通用标记语言应该使用 DTD 来规定应用于某种特定文档中的标签的规则，这些规则包括一系列的元素和实体的声明。
\item 在通用标记语言(SGML)的文档类型声明或 DTD 中，XHTML 被详细地进行了描述。
\item XHTML DTD 使用精确的可被计算机读取的语言来描述合法的 XHTML 标记的语法和句法。
\end{compactitem}

XHTML 1.0 规定了三种 XML 文档类型，以对应上述三种 DTD。

\begin{compactenum}
\item XHTML 1.0 Strict（严格类型）

\begin{lstlisting}[language=HTML]
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
\end{lstlisting}

在此情况下使用：需要干净的标记，避免表现上的混乱，而且需要与层叠样式表配合使用。

\item XHTML 1.0 Transitional（过渡类型）
\begin{lstlisting}[language=HTML]
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
\end{lstlisting}

在此情况下使用：当需要利用 HTML 在表现上的特性时，并且当需要为那些不支持层叠样式表的浏览器编写 XHTML 时。

\item XHTML 1.0 Frameset（框架类型）

\begin{lstlisting}[language=HTML]
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">

在此的情况下使用：需要使用HTML框架将浏览器窗口分割为两部分或更多框架时。
\end{lstlisting}
\end{compactenum}

XHTML文档的其余部分类似 HTML：

\begin{lstlisting}[language=HTML]
<html>
  <head>
    <title>simple document</title>
  </head>
  <body>
    <p>a simple paragraph</p>
  </body>
</html>
\end{lstlisting}




\section{XML declaration}

A character encoding may be specified at the beginning of an XHTML document in the XML declaration when the document is served using the application/xhtml+xml MIME type. (If an XML document lacks encoding specification, an XML parser assumes that the encoding is UTF-8 or UTF-16, unless the encoding has already been determined by a higher protocol.)


For example:

\begin{lstlisting}[language=XML]
	<?xml version="1.0" encoding="UTF-8" ?>
\end{lstlisting}


The declaration may be optionally omitted because it declares as its encoding the default encoding. However, if the document instead makes use of XML 1.1 or another character encoding, a declaration is necessary. Internet Explorer prior to version 7 enters quirks mode, if it encounters an XML declaration in a document served as text/html.


\section{Common errors}

Some of the most common errors in the usage of XHTML are:


\begin{compactitem}
\item Not closing empty elements (elements without closing tags in HTML4)

	\begin{compactitem}
	\item Incorrect: <br>
	\item Correct: <br />
	\end{compactitem}

Note that any of these is acceptable in XHTML: <br></br>, <br/>, and <br />. Older HTML-only browsers interpreting it as HTML will generally accept <br> and <br />.

\item Omitting end tags

	\begin{compactitem}
	\item Incorrect: <p>This is a paragraph.<p>This is another paragraph.
	\item Correct: <p>This is a paragraph.</p><p>This is another paragraph.</p>
	\end{compactitem}

\item Improperly nesting elements (Note that this would also be invalid in HTML)

	\begin{compactitem}
	\item Incorrect: <em><strong>This is some text.</em></strong>
	\item Correct: <em><strong>This is some text.</strong></em>
	\end{compactitem}

\item Not putting quotation marks around attribute values

	\begin{compactitem}
	\item Incorrect: <td rowspan=3>
	\item Incorrect: <td rowspan='3">
	\item Correct: <td rowspan="3">
	\item Correct: <td rowspan='3'>
	\end{compactitem}
	
\item Using the ampersand character outside of entities (Note that this would also be invalid in HTML)

	\begin{compactitem}
	\item Incorrect: <title>Cars \& Trucks</title>
	\item Correct: <title>Cars \&amp; Trucks</title>
	\item Incorrect: <a href="index.php?page=news\&id=5">News</a>
	\item Correct: <a href="index.php?page=news\&amp;id=5">News</a>
	\end{compactitem}

\item Failing to recognize that XHTML elements and attributes are case sensitive

	\begin{compactitem}
	\item Incorrect: <BODY><P ID="ONE">The Best Page Ever</P></BODY>
	\item Correct: <body><p id="ONE">The Best Page Ever</p></body>
	\end{compactitem}
	
\item Using attribute minimization
	
	\begin{compactitem}
	\item Incorrect: <textarea readonly>READ-ONLY</textarea>
	\item Correct: <textarea readonly="readonly">READ-ONLY</textarea>
	\end{compactitem}
	
\item Misusing CDATA, script-comments and xml-comments when embedding scripts and stylesheets.

	\begin{compactitem}
	\item This problem can be avoided altogether by putting all script and stylesheet information into separate files and referring to them as follows in the XHTML head element.
	\noindent\begin{lstlisting}[language=HTML]
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<script type="text/javascript" src="/script/site.js"></script>
	\end{lstlisting}
	
	Note: The format <script …></script>, rather than the more concise <script … />, is required for HTML compatibility when served as MIME type text/html.

	\item If an author chooses to include script or style data inline within an XHTML document, different approaches are recommended as shown in the examples below, depending whether the author intends to serve the page as application/xhtml+xml and target only fully conformant browsers, or serve the page as text/html and try to obtain usability in Internet Explorer 6 and other non-conformant browsers.
	\end{compactitem}

\end{compactitem}





\chapter{Backward compatibility}

XHTML 1.x documents are mostly backward compatible with HTML 4 user agents when the appropriate guidelines are followed. XHTML 1.1 is essentially compatible, although the elements for ruby annotation are not part of the HTML 4 specification and thus generally ignored by HTML 4 browsers. Later XHTML 1.x modules such as those for the role attribute, RDFa and WAI-ARIA degrade gracefully in a similar manner.

XHTML 2.0 is significantly less compatible, although this can be mitigated to some degree through the use of scripting. (This can be simple one-liners, such as the use of “document.createElement()” to register a new HTML element within Internet Explorer, or complete JavaScript frameworks, such as the FormFaces implementation of XForms.)




\section{Examples}


The following are examples of XHTML 1.0 Strict, with both having the same visual output. The former one follows the HTML Compatibility Guidelines of the XHTML Media Types Note while the latter one breaks backward compatibility, but provides cleaner markup.


\begin{table}
\centering
\caption{Media type recommendation for the examples}
\begin{tabular}{|l|l|l|}
\hline
Media type			&Example 1	&Example 2\\
\hline
application/xhtml+xml	&SHOULD	&SHOULD\\
\hline
application/xml		&MAY		&MAY\\
\hline
text/xml				&MAY		&MAY\\
\hline
text/html				&MAY		&SHOULD NOT\\
\hline
\end{tabular}
\end{table}

Example 1.

\begin{lstlisting}[language=HTML]
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <title>XHTML 1.0 Strict Example</title>
 <script type="text/javascript">
 //<![CDATA[
 function loadpdf() {
    document.getElementById("pdf-object").src="http://www.w3.org/TR/xhtml1/xhtml1.pdf";
 }
 //]]>
 </script>
 </head>
 <body onload="loadpdf()">
 <p>This is an example of an
 <abbr title="Extensible HyperText Markup Language">XHTML</abbr> 1.0 Strict document.<br />
 <img id="validation-icon"
    src="http://www.w3.org/Icons/valid-xhtml10"
    alt="Valid XHTML 1.0 Strict" /><br />
 <object id="pdf-object"
    name="pdf-object"
    type="application/pdf"
    data="http://www.w3.org/TR/xhtml1/xhtml1.pdf"
    width="100%"
    height="500">
 </object>
 </p>
 </body>
</html>
\end{lstlisting}

Example 2.

\begin{lstlisting}[language=HTML]
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
 <head>
 <title>XHTML 1.0 Strict Example</title>
 <script type="application/javascript">
 <![CDATA[
 function loadpdf() {
    document.getElementById("pdf-object").src="http://www.w3.org/TR/xhtml1/xhtml1.pdf";
 }
 ]]>
 </script>
 </head>
 <body onload="loadpdf()">
 <p>This is an example of an
 <abbr title="Extensible HyperText Markup Language">XHTML</abbr> 1.0 Strict document.<br/>
 <img id="validation-icon"
    src="http://www.w3.org/Icons/valid-xhtml10"
    alt="Valid XHTML 1.0 Strict"/><br />
 <object id="pdf-object"
    type="application/pdf"
    data="http://www.w3.org/TR/xhtml1/xhtml1.pdf"
    width="100%"
    height="500"/>
 </p>
 </body>
</html>
\end{lstlisting}


Notes:

\begin{compactenum}
\item The "loadpdf" function is actually a workaround for Internet Explorer. It can be replaced by adding <param name="src" value="http://www.w3.org/TR/xhtml1/xhtml1.pdf" /> within <object>.
\item The img element does not get a name attribute in the XHTML 1.0 Strict DTD. Use id instead.
\end{compactenum}




\chapter{Cross-compatibility of XHTML and HTML}



HTML5 and XHTML5 serializations are largely inter-compatible if adhering to the stricter XHTML5 syntax, but there are some cases in which XHTML will not work as valid HTML5 (e.g., processing instructions are deprecated in HTML, are treated as comments, and close on the first ">", whereas they are fully allowed in XML, are treated as their own type, and close on "?>").

\section{XHTML Website}

为了将站点从 HTML 转换为 XHTML，开发者首先应该熟悉前几章讲解的 XHTML 语法规则。

下面讲解具体的步骤。

\subsection{DTD}

将下面的文件类型声明添加至每页的首行：

\begin{lstlisting}[language=HTML]
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
\end{lstlisting}

如果希望将页面验证为正确的 XHTML，那么页面中必须含有文件类型声明。

需要注意的是，根据不同的文件类型声明，当前的浏览器对文档的处理方式也是不同的。如果浏览器读到一个文件类型声明，那么它会按照“恰当”的方式来处理文档。如果没有 DOCTYPE，文档也许会以截然不同的方式显示出来。



\subsection{Elements and Attributes}

XHTML 对大小写敏感，而且XHTML仅接受小写HTML 标签和属性名。


\subsection{Quotation marks}

W3C XHTML 1.0标准中要求所有的属性值都必须加引号。


\subsection{Empty elements}

在 XHTML 中是不允许使用空标签（Empty tags）的。<hr> 和 <br> 标签应该被替换为 <hr /> 和 <br />。

这样做又产生了一个新问题，Netscape 会误读 <br/> 标签。我们不清楚原因所在，不过将之改为 <br />后就没有问题了。

其他一些标签（比如 <img> 标签）也会碰到上述同样的问题。不要使用闭合标签来关闭 <img>，而是要在标签的末端添加 / >。


\subsection{XHTML validation}

根据官方的 W3C DTD 对所有修改过的页面进行验证： XHTML Validator。

XHTML 文档是根据文档类型声明（DTD）进行验证的。只有将正确的 DTD 添加到文件的首行，XHTML 文件才会被正确地验证，其中：

\begin{compactenum}
\item 严格 DTD 包含没有被反对使用的或不出现在框架结构中的元素和属性。

\begin{lstlisting}[language=HTML]
!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
\end{lstlisting}

\item 过渡 DTD 包含严格 DTD 中的一切，外加那些不赞成使用的元素和属性。

\begin{lstlisting}[language=HTML]
!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
\end{lstlisting}

\item 框架 DTD 包含过渡 DTD 中的一切，外加框架。

\begin{lstlisting}[language=HTML]
!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Frameset//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"
\end{lstlisting}

\end{compactenum}



接下来，可能还会有少数的错误被发现，逐一对这些错误进行（手工地）修正。我们的经验是，最容易犯的错误是在列表中漏掉了 </li> 标签。

也可以使用转换工具来将HTML代码转换成XHTML代码，比如HTML TIDY工具等。在处理那些由专门的 HTML 代码编辑器和转换工具生成的难以阅读的HTML代码方面，TIDY 还是做得很棒的。同时，它可以帮助你发现站点中哪些地方需要投入更多精力，使得对于残疾人士，网页具有更强的易用性。














\chapter{XHTML Modularization}


XHTML 是简单而庞大的语言，它包含了网站开发者需要的大多数功能。

对于某些特殊的用途，XHTML 太大且太复杂，而对于其他的用途，它又太简单了，于是通过XHTML 模块化模型定义了 XHTML 的模块。

通过将 XHTML 分为若干模块，W3C 已经创造出数套小巧且定义良好的 XHTML 元素，这些元素既可被独立应用于简易设备，又可以与其他 XML 标准并入大型且更复杂的应用程序。

通过使用模块化的 XHTML，产品和软件设计者可以：

\begin{compactitem}
\item 选择被某种设备所支持的元素。
\item 在不打破 XHTML 标准的情况下，使用 XML 对 XHTML 进行扩展。
\item 针对小型设备，对 XHTML 进行简化。
\item 通过添加新的 XML 功能（比如 MathML, SVG, 语音和多媒体），针对复杂的应用对 XHTML 进行扩展。
\item 定义 XHTML 框架，比如 XHTML BASIC （针对移动设备的 XHTML 子集）。
\end{compactitem}

W3C 已将 XHTML 的定义分为28种模型\footnote{注：已被废弃的元素不应被用于XHTML之中。}：

\begin{longtable}{|p{190pt}|p{190pt}|}
%head
\multicolumn{2}{r}{...}
\tabularnewline\hline
模块名称	&描述
\endhead
%endhead

%firsthead
\caption{XHTML 模块}\\
\hline
模块名称	&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{2}{r}{...}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
Applet Module (Applet模块)			&定义已被废弃的applet元素。\\
\hline
Base Module (基础模块)				&定义基本元素。\\
\hline
Basic Forms Module (基础表单模块)	&定义基本的表单元素 (forms)。\\
\hline
Basic Tables Module (基础表格模块)	&定义基本的表格元素 (table)。\\
\hline
Bi-directional Text Module (双向文本模块)	&定义bdo元素。\\
\hline
Client Image Map Module(客户端图像映射模块)	&定义浏览器端图像映射元素(image map elements)。\\
\hline
Edit Module (编辑模块)				&定义编辑元素删除和插入。\\
\hline
Forms Module (表单模块)			&定义所有在表单中使用的元素。\\
\hline
Frames Module (框架模块)			&定义frameset元素。\\
\hline
Hypertext Module (超文本模块)		&定义a元素。\\
\hline
Iframe Module (内联框架模块)		&定义iframe元素。\\
\hline
Image Module (图像模块)			&定义图像元素 (img)。\\
\hline
Intrinsic Events Module(事件属性模块)	&定义事件属性 (event)，比如onblur和onchange。\\
\hline
Legacy Module (遗留模块)			&定义被废弃的元素和属性。\\
\hline
Link Module (链接模块)				&定义链接 (link)元素。\\
\hline
List Module (列表模块)				&定义列表元素ol, li, ul, dd, dt,和dl。\\
\hline
Metainformation Module (元信息模块)	&定义meta元素。\\
\hline
Name Identification Module (名称识别模块)	&定义已被废弃的name属性。\\
\hline
Object Module (对象模块)			&定义对象元素 (object)和param元素。\\
\hline
Presentation Module (表现模块)		&定义表现元素比如b和i。\\
\hline
Scripting Module (脚本模块)			&定义脚本 (script)和无脚本 (noscript)元素。\\
\hline
Server Image Map Module(服务器端图像映射模块)	&定义服务器端图像映射(server side image map)元素。\\
\hline
Structure Module (结构模块)			&定义以下元素：html, head, title and body。\\
\hline
Style Attribute Module (样式属性模块)&定义样式属性。\\
\hline
Style Sheet Module (样式表模块)		&定义样式元素。\\
\hline
Tables Module (表格模块)			&定义用于表格中的元素。\\
\hline
Target Module (Target模块)			&定义target属性。\\
\hline
Text Module (文本模块)				&定义文本容器元素 (text container)，比如p和h1。\\
\hline



\end{longtable}





\chapter{XHTML Elements}

XHTML 元素是以 XML 格式编写的 HTML 元素。

每个元素都可以被结构化，CSS 可使得一个有序或无序的列表显示为彻头彻尾的导航栏，其中还拥有反转按钮效果。文档的内容可以通过普通的元素进行标记，这些元素通过特定的结构化属性标志来指示出它们在网站设计中所扮演的语义角色。






\chapter{XHTML Attributes}

XHTML 属性是以 XML 格式编写的 HTML 属性。

XHTML 标签拥有属性。每个标签的特殊属性均被列于每个标签描述之下。这里列出的属性是通用于每个标签的核心属性和语言属性（有个别例外）。


\section{Core Attributes}

以下标签不提供下面的属性：base, head, html, meta, param, script, style, 以及 title 元素。

\begin{longtable}{|p{50pt}|p{120pt}|p{150pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firshead
\caption{核心属性 (Core Attributes)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
class	&class\_rule或style\_rule	&元素的类(class)\\
\hline
id		&id\_name				&元素的某个特定id\\
\hline
style	&样式定义				&内联样式定义\\
\hline
title		&提示文本				&显示于提示工具中的文本\\
\hline

\end{longtable}








\section{Language Attributes}

以下标签不提供下面的属性：base, br, frame, frameset, hr, iframe, param, 以及 script 元素。

\begin{longtable}{|p{50pt}|p{120pt}|p{150pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firshead
\caption{语言属性 (Language Attributes)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
dir		&ltr | rtl		&设置文本的方向	\\
\hline
lang		&语言代码	&设置语言代码	\\
\hline


\end{longtable}



\section{Keyboard Attributes}


\begin{longtable}{|p{50pt}|p{120pt}|p{150pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firshead
\caption{键盘属性 (Keyboard Attributes)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
accesskey	&字符	&设置访问某元素的键盘快捷键\\
\hline
tabindex		&数		&设置某元素的Tab次序\\
\hline

\end{longtable}




\chapter{XHTML Events}


HTML 4.0 的新特性之一是使 HTML 事件触发浏览器中的行为，比方说当用户点击一个 HTML 元素时启动一段 JavaScript 。以下就是可被插入 HTML 标签以定义事件行为的一系列属性。




\section{Window Events}


仅在 body 和 frameset 元素中有效。

\begin{longtable}{|p{60pt}|p{40pt}|p{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firsthead
\caption{窗口事件 (Window Events)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
onload	&脚本	&当文档被载入时执行脚本\\
\hline
onunload	&脚本	&当文档被卸下时执行脚本\\
\hline
\end{longtable}

\section{Form Element Events}


仅在表单元素中有效。


\begin{longtable}{|p{60pt}|p{40pt}|p{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firsthead
\caption{表单元素事件 (Form Element Events)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
onchange	&脚本	&当元素改变时执行脚本\\
\hline
onsubmit	&脚本	&当表单被提交时执行脚本\\
\hline
onreset	&脚本	&当表单被重置时执行脚本\\
\hline
onselect	&脚本	&当元素被选取时执行脚本\\
\hline
onblur	&脚本	&当元素失去焦点时执行脚本\\
\hline
onfocus	&脚本	&当元素获得焦点时执行脚本\\
\hline
\end{longtable}

\section{Keyboard Events}

在下列元素中无效：base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style, 以及 title 元素。

\begin{longtable}{|p{60pt}|p{40pt}|p{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firsthead
\caption{键盘事件 (Keyboard Events)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
onkeydown	&脚本	&当键盘被按下时执行脚本\\
\hline
onkeypress	&脚本	&当键盘被按下后又松开时执行脚本\\
\hline
onkeyup		&脚本	&当键盘被松开时执行脚本\\
\hline

\end{longtable}


\section{Mouse Events}

在下列元素中无效：base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style, title 元素。


\begin{longtable}{|p{60pt}|p{40pt}|p{200pt}|}
%head
\multicolumn{3}{r}{}
\tabularnewline\hline
属性		&值		&描述
\endhead
%endhead

%firsthead
\caption{鼠标事件 (Mouse Events)}\\
\hline
属性		&值		&描述
\endfirsthead
%endfirsthead

%foot
\multicolumn{3}{r}{}
\endfoot
%endfoot

%lastfoot
\endlastfoot
%endlastfoot
\hline
onclick		&脚本	&当鼠标被单击时执行脚本\\
\hline
ondblclick	&脚本	&当鼠标被双击时执行脚本\\
\hline
onmousedown	&脚本	&当鼠标按钮被按下时执行脚本\\
\hline
onmousemove	&脚本	&当鼠标指针移动时执行脚本\\
\hline
onmouseout	&脚本	&当鼠标指针移出某元素时执行脚本\\
\hline
onmouseover	&脚本	&当鼠标指针悬停于某元素之上时执行脚本\\
\hline
onmouseup	&脚本	&当鼠标按钮被松开时执行脚本\\
\hline
\end{longtable}






\chapter{XHTML Basic}


XHTML Basic is an XML-based structured markup language primarily used for simple (mainly handheld) user agents, typically mobile devices.

XHTML Basic is a subset of XHTML 1.1, defined using XHTML Modularization including a reduced set of modules for document structure, images, forms, basic tables, and object support. XHTML Basic is suitable for mobile phones, PDAs, pagers, and settop boxes.

It will replace WML and C-HTML as more compliant user agents are developed.

One large advantage XHTML Basic has over WML and C-HTML is that XHTML Basic pages can be rendered differently in web browsers and on handhelds, without the need for two different versions of the same page.


In 2006, the specification was revised to version 1.1. Six new features have been incorporated into the language in order to better serve the small-device community.


\section{DOCTYPE}

To validate as XHTML Basic, a document must contain the following Document Type Declaration, or DOCTYPE:


\begin{lstlisting}[language=HTML]
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN"
	"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">
\end{lstlisting}


A complete valid and well-formed example is:

\begin{lstlisting}[language=HTML]
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN"
	    "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">
	<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
	  <head>
	    <title>Hello</title>
	  </head>
	  <body>
	    <p>Hello <a href="http://example.org/">world</a>.</p>
	  </body>
	</html>
\end{lstlisting}

Served with a MIME type of "application/xhtml+xml".

\section{XHTML-Print}

XHTML-Print, which became a W3C Recommendation in September 2006, is a specialized version of XHTML Basic designed for documents printed from information appliances to low-end printers.

\chapter{XHTML Mobile Profile}

XHTML Mobile Profile (XHTML MP) is a hypertextual computer language standard designed specifically for mobile phones and other resource-constrained devices.


It is an XHTML document type defined by the Open Mobile Alliance. XHTML-MP is derived from XHTML Basic 1.0 by adding XHTML Modules, with later versions of the standard adding more modules. However, for certain modules, XHTML-MP does not mandate a complete implementation so an XHTML-MP browser may not be fully conforming on all modules.

XHTML Basic 1.1 became a W3C Recommendation in July 2008, superseding XHTML-MP 1.2.

\section{DOCTYPE}

To validate as XHTML-MP, a document must contain a proper Document Type Declaration, or DOCTYPE, depending on the version of specification followed

\begin{lstlisting}[language=HTML]
	<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN"
	"http://www.wapforum.org/DTD/xhtml-mobile10.dtd">
	 
	<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.1//EN"
	"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile11.dtd">
	 
	<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN"
	"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">
\end{lstlisting}


Note that a series of revisions have been issued to correct technical errors in the above DTDs, and the DTD format is more complex and less widely supported than that of standard HTML

\section{MIME types}

The MIME type for XHTML Mobile Profile is "application/vnd.wap.xhtml+xml". Conforming user agents should also accept "application/xhtml+xml" and "text/html". Many desktop browsers will only validate XHTML-MP at display time, if an XML MIME type is specified.



\section{Development pitfalls}

Many problems arise when content written in XHTML is shown on different devices. For example, some devices will honor colors specified in CSS, while other devices will not. Building an adaptive application means delivering different content to different devices, according to their capabilities. This can bring huge complexity, given the number of different devices in the market with different hardware (screen-sizes, coloring capacity, buttons, memory and speed) and browsers. Software updates on mobile browsers are much more difficult than with desktop browsers, and as a result broken software tends to stay in use until the device is discarded.


Many software initiatives attempt to solve this problem. Most of these initiatives provide a proprietary language to write WAP content, which will render different content (XHTML-MP, WML, CHTML, etc.) according to the requesting device. One commercial initiative is WURFL, which uses a hierarchical XML configuration file mapping hundreds of device capabilities. WURFL also offers a "Wireless Abstraction Layer", called WALL, which specifies special tags that are automatically converted into a markup language supported by the device. The W3C DDWG has created a specification to standardize access to repositories of device capability information, to be part of a common framework for content adaptation technologies.


\section{Example}


A complete valid and well-formed example is:

\begin{lstlisting}[language=HTML]
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN"
	"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">
	<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
	  <head>
	    <title>Hello world</title>
	  </head>
	  <body>
	    <p>Hello <a href="http://example.org/">world</a>.</p>
	  </body>
	</html>
\end{lstlisting}

When served with a MIME type of ~``application/xhtml+xml" or ``application/vnd.wap.xhtml+xml".







\chapter{C-HTML}


C-HTML (short for Compact HyperText Markup Language), also called i-mode-HTML, is a subset of HTML for small information devices, such as first-generation smart phones and PDAs, such as DoCoMo's i-mode mobile phones used in Japan. C-HTML adds several features not found in standard HTML, notably accesskeys, phone number shortcuts for links, and emoji pictorial characters as locally extended Shift JIS, all concepts borrowed from HDML and WML.


Because small devices such as cellular phones have hardware restrictions such as lower memory, low-power CPUs with limited or no storage capabilities, small monochrome display screens, single-character fonts and restricted input methods (the absence of a keyboard or a mouse), there is a need for a simpler form of HTML.

C-HTML does not support tables, image maps, multiple fonts and styling of fonts, background colors and images, frames, or style sheets, and is limited to a monochromatic display.


The language is defined so that all the basic interactive operations can be done by a combination of four buttons and not by two-dimensional cursor movement: cursor forward, cursor backward, select, and back/stop. Functionality requiring two-dimensional cursor pointing, like image maps, are excluded from C-HTML.




\chapter{Reconstruction use XHTML}





\section{XHTML Rules}


将传统的 HTML 转换为 XHTML 1.0 是快捷且无痛的，只要遵守一些简单的规则和容易的方针。不管是否使用过 HTML，都不会妨碍使用 XHTML。

\begin{compactitem}
\item 使用恰当的文档类型声明和命名空间。
\item 使用 meta 元素声明内容类型。
\item 使用小写字母书写所有的元素和属性。
\item 为所有的属性值加引号。
\item 为所有的属性分配值。
\item 关闭所有的标签。
\item 使用空格和斜线关闭空标签。
\item 不要在注释中写双下划线。
\item 确保小于号及和号为 < 和 \&。
\end{compactitem}



\section{Charactersets,Unicode}

XML、XHTML、和HTML 4.0 文档的默认字符集是 Unicode，一个由 Unicode 联盟定义的标准。Unicode 是一套全面的字符集，它为每个字符提供了一个特定的唯一的数字，不论平台、程序和语言。Unicode 也是我们拥有的最接近通用字母表的事物，尽管它并不是一个字母表，而是一套数字映射方案。

尽管 Unicode 是 web 文档默认的字符集，开发人员依然可以自由地选择更适合他们的其他字符集。比方说，美国和西欧的网站常常使用 ISO-8859-1 (Latin-1) 编码，而中华人民共和国的国家标准是 gb2312。


\section{Semantic}


最大限度地使用 CSS 来进行布局。在 web 标准的世界里，XHTML 标记与表现无关，它只与文档结构有关。

结构良好的文档可以向浏览器传达尽可能多的语义，不论是浏览器位于掌上电脑还是时髦的桌面图形浏览器。结构良好的文档都能向用户传达可视化的语义，即使是在老的浏览器，或是在被用户关闭了 CSS 的现代浏览器中。

不是每个站点都能立即抛弃 HTML 表格布局。CSS 的发明者，W3C，直到 2002 年 11 月才将官方网站转换为 CSS 布局。然而，即使是顽固的唯标准主义者也不总是将表现从结构中完全分离处理，至少在 XHTML 1 中是做不到的。但是现在，我们可以向这个理想迈出重大的一步，通过将表现从结构中分离（或者说将数据从设计中），即使是混合的传统的布局也可从中受益。

下面有一些提示，可以帮助你通过更结构化的方式进行思维：

\begin{compactenum}
\item 提纲内的色彩

在语法学校，我们中的大部分人都被迫使用标准的提纲格式来写文章。现在，我们成为了设计师，可以多么自由地摆脱提纲的限制，然后大胆地投身于独特的个人表达的自由领域（也许我们的宣传册和商业站点还不是那么独特和个人化）。但是至少我们不会再受到提纲的困扰了。

实际上，依照 HTML，我们应该将内容结构化为有组织的层级。在浏览器不支持 CSS 的时期，我们无法在交付可供销售的布局的同时做到这一点。但是今天，在将我们的设计不折不扣地实现的同时，我们有能力交付内在结构良好的文档。

当将供网络使用的文本进行标记，或者当将已有的文本文档转换为网页时，使用传统提纲的这些条目进行思考。

\begin{lstlisting}[language=HTML]
<h1>我的主题</h1>
<p>介绍性文字</p>
<h2>补充性的观点</h2>
<p>相关文字</p>
\end{lstlisting}

同时，避免使用已被废弃的 HTML 元素比如 <font>，或者无语义的元素比如 <br />，来模拟其实不存在的逻辑结构。比如，不要像这样做：

\begin{lstlisting}[language=HTML]
<font size="7">我的主题</font><br />
介绍性文字<br /><br />
<font size="6">补充性的观点</font><br />
相关文字<br />
\end{lslisting}

\item 根据它们的意义使用元素，而不是根据它们的外观

我们中一些人已经陷在了一个坏习惯中，当我们仅仅需要一个大号字的文本时使用h1，或者在我们需要在前面加一个圆点符号时使用 li，而且浏览器一直都习惯于将设计属性强加于 HTML 元素之上。我们都一直习惯于认为，h1 意味着大号字，而li意味着圆点，或者 blockquote 意味着文本缩进。我们中的大多数人还在使用结构化元素模拟表现效果的方式来胡乱地写作 HTML。

同样地，假如设计师希望所有的标题使用相同的字号，就可能会将所有的标题设置为 h1，即使这么做毫无结构化语义可言。

\begin{lstlisting}[language=HTML]
<h1>这是主标题，在我将文本按照提纲格式组织的情况下。</h1>
<h1>这不是主标题，但是我希望它与上面的标题使用一样的字体，但是我不知该如何使用CSS。</h1>
<h1>这根本不是一个标题。但是我非常希望页面中的文字使用相同的字体，以达到我希望的，
如果我了解CSS，就可以在不打乱文档结构的情况下达到这个设计。</h1>
\end{lstlisting}

现在必须把这些小把戏放到一边，然后开始根据元素的语义来使用它们，而不是根据它们看上去的样子。实际上，h1可以成为用户希望的任何样子。通过 CSS，h1 可以成为非粗体的小号的罗马字体，而 p 文本可以成为粗体的大号字，li 也可以没有圆点（或者还可以使用小猫小狗或者公司标志的 PNG,GIF 或者 JPEG 图片取而代之）等等。

网站重构以后将使用 CSS 来决定元素的外观，甚至可以根据元素在页面中或者在站点中所在的位置来改变它们的外观。 CSS可以将表现从结构中彻底抽离，并且允许开发者按照他们喜欢的样式来格式化任何元素。

\begin{lstlisting}[language=CSS]
h1, h2, h3, h4, h5, h6 {
	font-family: georgia, palatino, "New Century Schoolbook",
	times, serif;
	font-weight: normal;
	font-size: 2em;
	margin-top: 1em;
	margin-bottom: 0;
	}
\end{lstlisting}

采取上述这种做法的目的是为了在图形浏览器中获得品牌化的外观和感觉的同时，在文本浏览器、无线设备、HTML 格式的电子邮件中，文档的结构得到保留。

\item 使用结构化元素，而不是无意义的垃圾

由于我们已经忘记或者根本不知道 HTML 和 XHTML 的用途是传达结构化的意义，许多 HTML 争论者这样使用标签来插入列表：

\begin{lstlisting}[language=HTML]
项目一<br />
项目二<br />
项目三<br />
\end{lstlisting}

现在，可以考虑一下使用有序或者无序列表取而代之：

\begin{lstlisting}[language=HTML]
<ul>
<li>项目一</li>
<li>项目二</li>
<li>项目三</li>
</ul>
\end{lstlisting}

``但是li给我一个圆点，而我不需要圆点！"你也许会这么说。根据上面的章节，CSS不对元素被期望的外观做任何假定。它等待你来告诉它你所期待的元素外观，而关闭圆点是 CSS 的最基本的能力。它有能力使列表看起来和普通文本没有两样，也可以使列表看起来像图形导航栏，具有完整的反转效果。

所以，列表就应该使用列表元素来标记。相似地，使用 strong 来代替 b，使用 em 代替 i，等等。在大多数桌面浏览器缺省状态下，strong 的显示效果和 b 相同，而 em 和 i 相同，同时也可以在不破坏文档结构的情况下创建期待的视觉效果。

尽管 CSS 不会为任何元素的显示作假设，浏览器却作了很多假设，并且我们还没有碰到一个将 strong 显示为其他效果而不是粗体字的浏览器（除非是被设计师创建的 CSS 指示以其他方式显示）。如果担心某个陌生的浏览器不会将 strong 显示为粗体字，则可以编写这么一条 CSS 规则：

\begin{lstlisting}[language=CSS]
strong {
	font-weight: bold;
	font-style: normal;
	}
\end{lstlisting}

\item 视觉元素和结构

web 标准不仅要求我们使用何种技术，而且还要遵守使用这些技术的方式。使用 XHTML 来编写标记，同时使用 CSS 来处理一部分或者全部的布局，并不一定会使站点更易用更轻便，同时节约多少带宽。就像我们在早期使用的技术那样，XHTML 和 CSS 也会被误用和滥用。冗长的 XHTML 和冗长的 HTML 一样，都会浪费用户的带宽和时间。冗长的过度的 CSS 也不能完全的代替表现 HTML 代码；这只不过是一种糟糕的东西被另一种代替了而已。

\end{compactenum}



































